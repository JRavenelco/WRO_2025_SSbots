#!/usr/bin/env python3
#se importan todas las librerias necesarias
import time, queue, serial, subprocess, os, pty, threading, lgpio, board, adafruit_vl53l1x
from dataclasses import dataclass
from math import floor
from rplidar import RPLidar, RPLidarException
import numpy as np

#se define la clase para el hilo del lidar
@dataclass
class RPlidar_data:          
    dist_left: int  
    dist_75: int 
    dist_315: int
    dist_right: int 
    area: float  

@dataclass
class Distance_data:
    distance_izq: int
    distance_derecho: int
    distance_trasero: int

#se define la clase para el hilo del sensor tof
@dataclass
class Sensor_tof_data:
    identifier : adafruit_vl53l1x.VL53L1X #adafruit_vl53l0x.VL53L0X
    name : str
    slave_address : int
    pin_gpio_enable :int   

#se guardan los sensores en una lista
SENSORS = [
    Sensor_tof_data(None,"izquierda", slave_address=0x26, pin_gpio_enable =16),
    Sensor_tof_data(None,"derecho", slave_address=0x28, pin_gpio_enable =20),
    Sensor_tof_data(None,"trasero", slave_address=0x29, pin_gpio_enable =21)
]


running = True
vision_queue: "queue.Queue[RPlidar_data]" = queue.Queue(maxsize=1) #se define la cola para el hilo del lidar
distance_queue: "queue.Queue[Distance_data]" = queue.Queue(maxsize=1) #se define la cola para el hilo del sensor tof

#se crea el lidar y se define su puerto
PORT_NAME = "/dev/ttyUSB0"
lidar = RPLidar(PORT_NAME)

#se crea el sensor tof y se define su puerto
i2c = board.I2C() #i2c = busio.I2C(board.SCL, board.SDA)
 

#se define la funcion que inicia el screen
def screenSimplified():
    if not os.path.exists("/dev/ttyACM0"):
        return

    master_fd, slave_fd = pty.openpty() 
    
    subprocess.Popen( 
        ["screen", "/dev/ttyACM0", "115200"],
        stdin=slave_fd, 
        stdout=slave_fd,
        stderr=slave_fd,
    )

    os.close(slave_fd)
    time.sleep(1.0)
    os.write(master_fd, b'\x03') # Send Ctrl+C to screen
    time.sleep(0.2)
    os.write(master_fd, b'\x01') # Send Ctrl+A to screen
    time.sleep(0.2)
    os.write(master_fd, b'k') # Send 'k' to kill the screen session
    time.sleep(0.2)
    os.write(master_fd, b'y') # Send 'y' to confirm kill
    time.sleep(0.2)
    
    os.close(master_fd)

#se corre el screen para el spike

    
#se define la variable para el spike
spike = None
#variables globales rasp
der = 1
izq = -1

#Todas las funciones que se mandan por serial para el spike
def initialize_Libraries():
    spike.write("import motor\r".encode()) 
    spike.readline()
    spike.write("from hub import port\r".encode())
    spike.readline()#clear buffer
    spike.write("from hub import motion_sensor\r".encode())
    spike.readline()#clear buffer
    spike.write("import distance_sensor\r".encode())
    spike.readline()#clear buffer
    #declare varianbles globales spike
    spike.write("der = -1\r".encode())
    spike.readline() #clear buffer
    spike.write("izq = 1\r".encode())
    spike.readline() #clear buffer
    spike.write("error = 0\r".encode())
    spike.readline() #clear buffer
    #declare functions for motors
    spike.write("def Hold():\r".encode())
    spike.readline() #clear buffer 
    spike.write("motor.stop(port.F, stop = motor.HOLD)\r".encode())
    spike.readline() #clear buffer 
    spike.write("motor.stop(port.B, stop = motor.HOLD)\r".encode())
    spike.readline() #clear buffer
    end_Function()

    spike.write("def fc():\r".encode())
    spike.readline() #clear buffer 
    spike.write("motor.stop(port.F, stop = motor.COAST)\r".encode())
    spike.readline() #clear buffer 
    spike.write("motor.stop(port.B, stop = motor.COAST)\r".encode())
    spike.readline() #clear buffer
    end_Function()

    # centrar el vehiculo normal
    spike.write("def cv():\r".encode())
    spike.readline() #clear buffer 
    spike.write("motor.run_to_absolute_position(port.F, 0, 550,\r".encode())
    spike.readline()#clear buffemotor.stop(port.F, stop = motor.COAST)r
    spike.write("direction = motor.LONGEST_PATH, stop = motor.HOLD, acceleration = 1000, deceleration = 1000)\r".encode())
    spike.readline() #clear buffer
    spike.write("return 255\r".encode())
    spike.readline() #clear buffer
    end_Function()

    # centrar el vehiculo corto
    spike.write("def cvc():\r".encode())
    spike.readline() #clear buffer 
    spike.write("motor.run_to_absolute_position(port.F, 0, 550,\r".encode())
    spike.readline()#clear buffemotor.stop(port.F, stop = motor.COAST)r
    spike.write("direction = motor.SHORTEST_PATH, stop = motor.HOLD, acceleration = 1000, deceleration = 1000)\r".encode())
    spike.readline() #clear buffer
    spike.write("return 255\r".encode())
    spike.readline() #clear buffer
    end_Function()

    #pd 
    spike.write("def pd(s1,s2,vel,kp,kd,ea):\r".encode()) #ea es error anterior
    spike.readline() #clear buffer 
    spike.write("error=s1-s2\r".encode())
    spike.readline()#clear buffer
    spike.write("et= (kp*error) + (kd*(error-ea))\r".encode()) #et es error total
    spike.readline()#clear buffer
    spike.readline() #clear buffer
    spike.write("motor.run_to_absolute_position(port.F, int(et*6.4), 600, direction = motor.SHORTEST_PATH, stop = motor.HOLD, acceleration = 10000)\r".encode())
    spike.readline() #clear buffer
    spike.write("motor.set_duty_cycle(port.B, (100)*(vel))\r".encode())
    spike.readline() #clear buffer
    spike.write("return error\r".encode())
    spike.readline() #clear buffer
    end_Function()

    #reset Gyro
    spike.write("def rg(grados):\r".encode())
    spike.readline() #clear buffer
    spike.write("motion_sensor.reset_yaw(grados)\r".encode())
    spike.readline() #clear buffer
    end_Function()

    #imprimir giroscopio
    spike.write("def pg():\r".encode())
    spike.readline() #clear buffer
    spike.write("return motion_sensor.tilt_angles()[0]\r".encode())
    spike.readline() #clear buffer
    end_Function()

    #avanzar derecho
    spike.write("def ad(vel,referencia):\r".encode())
    spike.readline() #clear buffer
    spike.write("global error\r".encode())
    spike.readline() #clear buffer
    spike.write("error = pd(((10)*(referencia)),motion_sensor.tilt_angles()[0],vel,0.3,1,error)\r".encode())
    spike.readline() #clear buffer 
    end_Function()

    spike.write("def vuelta(direccion,velocidad,grados):\r".encode())
    spike.readline() #clear buffer
    spike.write("motor.run_to_relative_position(port.F, 313*(direccion), 550)\r".encode())
    spike.readline() #clear buffer
    spike.write("while abs(grados*10) > abs(motion_sensor.tilt_angles()[0]):\r".encode())
    spike.readline() #clear buffer
    spike.write("motor.set_duty_cycle(port.B, (100)*(velocidad))\r".encode())
    spike.readline() #clear buffer
    spike.write(chr(127).encode()) #suprimir linea
    spike.readline() #clear buffer
    spike.write("fc()\r".encode())   
    spike.readline() #clear buffer
    spike.write("return 255\r".encode())
    spike.readline() #clear buffer
    end_Function()
    end_Function()

    spike.write("def da(vel, referencia):\r".encode())
    spike.readline() #clear buffer
    spike.write("global error\r".encode())
    spike.readline() #clear buffer
    spike.write("error = pd(motion_sensor.tilt_angles()[0],referencia,vel,0.3,1,error)\r".encode())
    spike.readline() #clear buffer
    end_Function()

    spike.write("def ag(vel,grados,referencia):\r".encode())
    spike.readline() #clear buffer
    spike.write("error = 0\r".encode())
    spike.readline() #clear buffer
    spike.write("motor.reset_relative_position(port.B,0)\r".encode())
    spike.readline() #clear buffer
    spike.write("while abs(grados) > abs(motor.relative_position(port.B)):\r".encode())
    spike.readline() #clear buffer
    spike.write("error = pd(motion_sensor.tilt_angles()[0],((10)*(referencia)),vel,0.3,10,error)\r".encode())
    spike.readline() #clear buffer
    spike.write(chr(127).encode()) #suprimir linea
    spike.readline() #clear buffer
    spike.write("fc()\r".encode())
    spike.readline() #clear buffer
    spike.write("return 255\r".encode())
    spike.readline() #clear buffer
    end_Function()
    end_Function()

    spike.write("def spd(vel,distancia,sensor):\r".encode())
    spike.readline() #clear buffer
    spike.write("global error\r".encode())
    spike.readline() #clear buffer
    spike.write("error = pd(distancia,sensor,vel,0.3,1,error)\r".encode())
    spike.readline() #clear buffer
    spike.write("return motor.relative_position(port.B)\r".encode())
    spike.readline() #clear buffer
    end_Function()

    spike.write("def spi(vel,distancia,sensor):\r".encode())
    spike.readline() #clear buffer
    spike.write("global error\r".encode())
    spike.readline() #clear buffer
    spike.write("error = pd(sensor,distancia,vel,0.3,1,error)\r".encode())
    spike.readline() #clear buffer
    spike.write("return motor.relative_position(port.B)\r".encode())
    spike.readline() #clear buffer
    end_Function()

#se hacen las funciones en la rasp que utilizan las funciones mandadas por serial
def centrar_vehiculo():
    spike.write("cv()\r".encode())
    spike.readline() #limpia el buffer 
    return_value = spike.readline().decode()
    if return_value == "":
        return_value = "0"
    while int(return_value) != 255:
        return_value = spike.readline().decode()
        if return_value == "":
            return_value = "0"

    

def centrar_vehiculo_corto():
    spike.write("cvc()\r".encode())
    spike.readline() #limpia el buffer 
    return_value = spike.readline().decode()
    if return_value == "":
        return_value = "0"
    while int(return_value) != 255:
        return_value = spike.readline().decode()
        if return_value == "":
            return_value = "0"

def Hold_motors():
    spike.write("Hold()\r".encode())
    spike.readline() #clear buffer

def Coast_motors():
    spike.write("fc()\r".encode())
    spike.readline() #clear buffer


def end_Function():
    spike.write("\r".encode())
    spike.readline()#clear 
    spike.write("\r".encode())
    spike.readline()#clear buffer
    spike.write("\r".encode())
    spike.readline()#clear buffer
    
def reset_gyro(grados):
    spike.write(("rg("+str(grados)+")\r").encode())
    spike.readline() #clear buffer

def print_gyro():
    spike.write("pg()\r".encode())
    spike.readline() #clear buffer
    return_value = spike.readline().decode()
    print("grioscopio: ",return_value)
    
def avanzar_distancia(vel,distancia,referencia):
    #avanzar cierta distancia sensro del fente, creo que no se ocupo 
    pass

def vuelta_grados(direccion,velocidad,grados):
    spike.write(("vuelta("+str(direccion)+","+str(velocidad)+","+str(grados)+")\r").encode())
    spike.readline() #clear buffer
    return_value = spike.readline().decode()
    if return_value == "":
        return_value = "0"
    while int(return_value) != 255:
        return_value = spike.readline().decode()
        if return_value == "":
            return_value = "0"
    print("Fin de la vuelta")
    Coast_motors()

def avanzar_detection_lidar(vel,referencia):
    try:
        while not vision_queue.full():
            print("ESPERANDO EL QUEVE PARA DETECTAR EL VACIO AMBOS\n")
        obj = vision_queue.get()
        while obj.dist_left < 1350 and obj.dist_right < 1350:
            spike.write(("da("+str(vel)+","+str(referencia)+")\r").encode())
            spike.readline() #clear buffer
            if vision_queue.full():
                print("obtuvo el queve")
                obj = vision_queue.get()
            time.sleep(0.001)
            print(obj.dist_left, obj.dist_right)
        Coast_motors()
        if obj.dist_left > 1350:
            print(obj.dist_left)
            return izq
        elif obj.dist_right > 1350:
            print(obj.dist_right)
            return der
    except queue.Empty:
        pass
    except KeyboardInterrupt:
        Coast_motors()
        
def avanzar_detection_izquierdo_lidar(vel,referencia):
    try:
        while not vision_queue.full():
            print("ESPERANDO EL QUEVE PARA DETECTAR EL VACIO IZQUIERDO\n")
        obj = vision_queue.get()
        while obj.dist_left < 1350:
            spike.write(("da("+str(vel)+","+str(referencia)+")\r").encode())
            spike.readline() #clear buffer
            if vision_queue.full():
                print("obtuvo el queve")
                obj = vision_queue.get()
        Coast_motors()
        print(obj.dist_left)
    except queue.Empty:
        pass
    except KeyboardInterrupt:
        Coast_motors()
    
def avanzar_detection_derecho_lidar(vel,referencia):
    try:
        while not vision_queue.full():
            print("ESPERANDO EL QUEVE PARA DETECTAR EL VACIO DERECHO\n")
        obj = vision_queue.get()
        while obj.dist_right < 1350:
            spike.write(("da("+str(vel)+","+str(referencia)+")\r").encode())
            spike.readline() #clear buffer
            if vision_queue.full():
                obj = vision_queue.get()
        Coast_motors()
    except queue.Empty:
        pass
    except KeyboardInterrupt:
        Coast_motors()

def vuelta_automatica(velocidad, grados):
    der = 1
    izq = -1
    while not vision_queue.full():
        print("ESPERANDO EL QUEVE PARA LA VUELTA\n")
    obj = vision_queue.get()
    print(obj.dist_right, obj.dist_left)
    if obj.dist_right > 1350:
        vuelta_grados(der,velocidad,grados)
    elif obj.dist_left > 1350:
        vuelta_grados(izq,velocidad,grados)
    Coast_motors()

def avanzar_recto_grados(velocidad,grados,referencia):
    spike.write(("ag("+str(velocidad)+","+str(grados)+","+str(referencia)+")\r").encode())
    spike.readline() #clear buffer
    return_value = spike.readline().decode()
    if return_value == "":
        return_value = "0"
    while int(return_value) != 255:
        return_value = spike.readline().decode()
        if return_value == "":
            return_value = "0"
    print("FIN DE LA FUNCION AVANZAR RECTO GRADOS")
    Coast_motors()

def seguir_pared_derecho(velocidad,grados):
    #es la funcion de ale que utiliza dos puntos en la pared y se corrige con el sensor derecho
    pass

def seguir_pared_izquierdo(velocidad,grados):
    #es la funcion de ale que utiliza dos puntos en la pared y se corrige con el sensor izquierdo
    pass
    
#funcion para el lidar que obtiene las medidas en angulos especificos
def RPlidar_worker():
    try:
        lidar.stop()
        time.sleep(0.2)
        lidar.clean_input()
        angles = [0]*360
        for scan in lidar.iter_scans(scan_type='express',max_buf_meas= 4000,min_len=0):
            for (_, angle, distance) in scan:
                angles[min([359,floor(angle)])] = distance
            lidar_data = RPlidar_data(angles[90],angles[75], angles[80],angles[85],angles[95],angles[270],angles[285],angles[280],angles[275],angles[265])
            if vision_queue.full(): #check if the queue is full
                try:
                    print("queue full lidar listo")
                    vision_queue.get() 
                except vision_queue.not_empty:
                    pass
            vision_queue.put(lidar_data) 
            #vision_queue.task_done()
    except RPLidarException as e:
        print("error in lidar",e)
        lidar.clean_input()

#convercion de grados a radianes
def grados_a_radianes(grados):
    grados_convertidos : int = (grados)/(180/np.pi)
    return grados_convertidos

#convercion de radianes a grados
def radianes_a_grados(radianes):
    radianes_convertidos : int = (radianes)*(180/np.pi)
    return radianes_convertidos

#funcion que calcula la correcion del giroscopio utilizando medidas del lidar y funciones trigonométricas
def correccion_izquierda():
    #todas las funciones trigonométricas usan radianes como entrada
    if vision_queue.full():
        try:
            obj = vision_queue.get_nowait()
            H = int(obj.dist_75*10) #Distancia a 75 grados
            H_80 = int(obj.dist_80*10)
            CA = int(obj.dist_left*10) #distancia izquierda del lidar
            L_85 = int(obj.dist_85*10)
            L_95 = int(obj.dist_95*10)
            print(CA,H, H_80, L_85, L_95)

            if (H == 0 or H > 4000) and H_80 == 0:
                lado_faltante = np.sqrt((L_85**2) + (L_95**2)- (2*L_85*L_95*np.cos(grados_a_radianes(10))))
                ley_de_senos = L_85*np.sin(grados_a_radianes(10))
                angulo_correccion = radianes_a_grados(np.arcsin(ley_de_senos/lado_faltante))
                comparacion = L_95/L_85
                if comparacion < 1 or comparacion == np.nan: #si el robot esta inclinado hacia afuera
                    angulo_correccion = 170-angulo_correccion
                else:
                    angulo_correccion = angulo_correccion
                angulo_correccion = int((angulo_correccion-85)*-10)
                print("tercer triangulo")

            elif H == 0 or H > 5000:
                lado_faltante = np.sqrt((H_80**2) + (CA**2)- (2*H_80*CA*np.cos(grados_a_radianes(10))))
                ley_de_senos = H_80*np.sin(grados_a_radianes(10))
                angulo_correccion = radianes_a_grados(np.arcsin(ley_de_senos/lado_faltante))
                comparacion = radianes_a_grados(np.arcsin(CA/H_80))
                if comparacion < 80 or comparacion == np.nan: #si el robot esta inclinado hacia afuera
                    angulo_correccion = 180-angulo_correccion
                else:
                    angulo_correccion = angulo_correccion
                angulo_correccion = int((angulo_correccion-90)*-10)
                print("segundo triangulo")

            else:
                #calculo con 90 y 80 grados
                lado_faltante = np.sqrt((H**2) + (CA**2)- (2*H*CA*np.cos(grados_a_radianes(15))))
                ley_de_senos = H*np.sin(grados_a_radianes(15))
                angulo_correccion = radianes_a_grados(np.arcsin(ley_de_senos/lado_faltante))
                comparacion = radianes_a_grados(np.arcsin(CA/H))
                if comparacion < 75 or comparacion == np.nan: #si el robot esta inclinado hacia afuera
                    angulo_correccion = 180-angulo_correccion
                else:
                    angulo_correccion = angulo_correccion
                angulo_correccion = int((angulo_correccion-90)*-10)
                print("primer triangulo")      
            
            print("angulo correccion: ",angulo_correccion)
            return angulo_correccion
        except queue.Empty:
            pass
    
    else:
        return None

def correccion_derecha(correcion_del_angulo):
    #todas las funciones trigonométricas usan radianes como entrada
    if vision_queue.full():
        try:
            obj = vision_queue.get_nowait()
            H = int(obj.dist_285*10) #Distancia a 75 grados
            H_280 = int(obj.dist_280*10)
            CA = int(obj.dist_right*10) #distancia izquierda del lidar
            L_265 = int(obj.dist_265*10)
            L_275 = int(obj.dist_275*10)
            print(CA,H, H_280, L_275, L_265)

            if (H == 0 or H > 4000) and H_280 == 0:
                lado_faltante = np.sqrt((L_265**2) + (L_275**2)- (2*L_265*L_275*np.cos(grados_a_radianes(10))))
                ley_de_senos = L_265*np.sin(grados_a_radianes(10))
                angulo_correccion = radianes_a_grados(np.arcsin(ley_de_senos/lado_faltante))
                comparacion = L_265/L_275
                if comparacion < 1 or comparacion == np.nan: #si el robot esta inclinado hacia afuera
                    angulo_correccion = 170-angulo_correccion
                else:
                    angulo_correccion = angulo_correccion
                angulo_correccion = int((angulo_correccion-85)*10)
                print("tercer triangulo")

            elif H == 0 or H > 5000:
                lado_faltante = np.sqrt((H_280**2) + (CA**2)- (2*H_280*CA*np.cos(grados_a_radianes(10))))
                ley_de_senos = H_280*np.sin(grados_a_radianes(10))
                angulo_correccion = radianes_a_grados(np.arcsin(ley_de_senos/lado_faltante))
                comparacion = radianes_a_grados(np.arcsin(CA/H_280))
                if comparacion < 80 or comparacion == np.nan: #si el robot esta inclinado hacia afuera
                    angulo_correccion = 180-angulo_correccion
                else:
                    angulo_correccion = angulo_correccion
                angulo_correccion = int((angulo_correccion-90)*10)
                print("segundo triangulo")

            else:
                #calculo con 90 y 80 grados
                lado_faltante = np.sqrt((H**2) + (CA**2)- (2*H*CA*np.cos(grados_a_radianes(15))))
                ley_de_senos = H*np.sin(grados_a_radianes(15))
                angulo_correccion = radianes_a_grados(np.arcsin(ley_de_senos/lado_faltante))
                comparacion = radianes_a_grados(np.arcsin(CA/H))
                if comparacion < 75 or comparacion == np.nan: #si el robot esta inclinado hacia afuera
                    angulo_correccion = 180-angulo_correccion
                else:
                    angulo_correccion = angulo_correccion
                angulo_correccion = int((angulo_correccion-90)*10)
                print("primer triangulo")      
            
            print("angulo correccion: ",angulo_correccion)
            return angulo_correccion
        except queue.Empty:
            pass
    
    else:
        return None



    if vision_queue.full():
        try:
            obj = vision_queue.get_nowait()
            H = int(obj.dist_285*10) #Distancia a 75 grados
            CA = int(obj.dist_right*10) #distancia izquierda del lidar
            lado_faltante = np.sqrt((H**2) + (CA**2)- (2*H*CA*np.cos(grados_a_radianes(correcion_del_angulo))))
            ley_de_senos = H*np.sin(grados_a_radianes(correcion_del_angulo))
            angulo_correccion = radianes_a_grados(np.arcsin(ley_de_senos/lado_faltante))
            comparacion = radianes_a_grados(np.arcsin(CA/H))
            #print(comparacion)
            if comparacion < 75 or comparacion == np.nan: #si el robot esta inclinado hacia afuera
                angulo_correccion = 180-angulo_correccion
            else:
                angulo_correccion = angulo_correccion
            angulo_correccion = int((angulo_correccion-90)*10)
            print(angulo_correccion)
            return angulo_correccion
        except queue.Empty:
            pass

#funcion que habilita el acceso a los gpio
def setup_gpio():
    try:
        h = lgpio.gpiochip_open(0) #se habilita el acceso a los gpio
        """lgpio.gpio_claim_input(h, 4)
        lgpio.gpio_claim_output(h, 12)
        lgpio.gpio_claim_output(h, 17)
        lgpio.gpio_write(h, 12, 1)
        lgpio.gpio_write(h, 17, 1)
        for sensor in SENSORS:
            lgpio.gpio_claim_output(h, sensor.pin_gpio_enable)
            lgpio.gpio_write(h, sensor.pin_gpio_enable, 0)
            time.sleep(0.5)
        for sensor in SENSORS:
            lgpio.gpio_write(h, sensor.pin_gpio_enable, 1)
            time.sleep(0.5)
            sensor.identifier = adafruit_vl53l1x.VL53L1X(i2c)
            print(sensor.identifier.model_info)
            sensor.identifier.distance_mode = 1
            sensor.identifier.timing_budget = 33
            sensor.identifier.roi_center = 199
            print(sensor.identifier.roi_center) 
            sensor.identifier.roi_xy = (16,8)
            print(sensor.identifier.roi_xy) 
            sensor.identifier.set_address(sensor.slave_address)
        lgpio.gpio_write(h, 12, 0)"""
        print("GPIO inicializados")
        return h, True

    except Exception as e:
        print(f"Error al inicializar sensores: {e}")
        return h, False

#funcion que limpia los gpio
def cleanup_gpio(h):
    try:
        for sensor in SENSORS:
            try:
                lgpio.gpio_free(h, sensor.pin_gpio_enable)
            except:
                pass
        lgpio.gpio_free(h, 4) 
        lgpio.gpio_write(h, 12, 1)
        lgpio.gpio_write(h, 17, 1)
        lgpio.gpiochip_close(h)
        print("GPIO libres")
    except:
        pass

def sensor_worker():
    for sensor in SENSORS:
        sensor.identifier.start_ranging()
    obj = Distance_data(0,0,0)
    distancias = [0,0,0]
    while 1:
        try:
            for i,sensor in enumerate(SENSORS):
                if sensor.identifier.data_ready:
                    distancias[i] = sensor.identifier.distance 
                    sensor.identifier.clear_interrupt()
            if distancias[0] != 0 or distancias[0] == None:
                obj.distance_izq = distancias[0]
            if distancias[1] != 0 or distancias[1] == None:
                obj.distance_derecho = distancias[1]
            if distancias[2] != 0 or distancias[2] == None:
                obj.distance_trasero = distancias[2]

            if distance_queue.full(): 
                try:
                    distance_queue.get() # erase old values from the queue to have latest information 
                except distance_queue.not_empty:
                    pass
            if obj.distance_izq != 0 or obj.distance_derecho != 0 or obj.distance_trasero != 0 or obj.distance_izq == None or obj.distance_derecho == None or obj.distance_trasero == None:
                distance_queue.put(obj)
                distance_queue.task_done() 
            time.sleep(0.01)
        except Exception as e:
            print(f"Error al leer sensor: {e}")

def main():
    global running, spike
    h, success = setup_gpio()
    try:
        spike = serial.Serial('/dev/ttyACM0', 115200, timeout=1)
        screenSimplified()
        initialize_Libraries()
        threading.Thread(target=sensor_worker).start()
        threading.Thread(target=RPlidar_worker).start()
        reset_gyro(0)
        time.sleep(0.1)
        print_gyro()
        """print("presiona el boton\n")
        while(lgpio.gpio_read(h, 4) == 1):
            lgpio.gpio_write(h, 17, 1)
            time.sleep(0.05)
            lgpio.gpio_write(h, 17, 0)
            time.sleep(0.05)
        lgpio.gpio_write(h, 17, 0)"""
        print("empezando ....\n")
        
        while running:
            try:
                """if vision_queue.full():
                    try:
                        obj = vision_queue.get_nowait()
                        print(obj.dist_left, obj.dist_80)
                    except queue.Empty:
                        pass
                angulo_correccion = correccion_izquierda()
                if angulo_correccion != None:
                    print(angulo_correccion)
                """
                while not vision_queue.full():
                    print("esperando lidar\n")
                obj_lidar = vision_queue.get()
                v = 0

                if obj_lidar.dist_left > 700 or obj_lidar.dist_right > 700:
                    
                    direccion = avanzar_detection_lidar(60,0)
                    time.sleep(1)
                    avanzar_recto_grados(60,300,0) # se va a aquitar con sensores

                    if direccion == izq:
                        vuelta_grados(izq,60,88)
                        centrar_vehiculo()
                        time.sleep(1)
                        avanzar_recto_grados(60,1600,90)
                        angulo_correcion = correccion_izquierda()
                        reset_gyro(angulo_correcion)
                        time.sleep(0.1)
                        while v < 11:
                            avanzar_detection_izquierdo_lidar(60,0)
                            avanzar_recto_grados(60,300,90) # se va a aquitar con sensores
                            vuelta_grados(izq,60,88)
                            centrar_vehiculo()
                            time.sleep(1)
                            avanzar_recto_grados(60,900,90)
                            reset_gyro(0)
                            angulo_correcion = correccion_izquierda()
                            reset_gyro(angulo_correcion)
                            print_gyro()
                            time.sleep(0.1)
                            v = v + 1
                        avanzar_recto_grados(60,550,0)
                    
                    if direccion == der:
                        vuelta_grados(der,60,88)
                        centrar_vehiculo()
                        time.sleep(1)
                        avanzar_recto_grados(60,1600,-90)
                        angulo_correcion = correccion_derecha(15)
                        reset_gyro(angulo_correcion)
                        time.sleep(0.1)
                        while v < 11:
                            avanzar_detection_derecho_lidar(60,0)
                            vuelta_grados(der,60,88)
                            centrar_vehiculo()
                            time.sleep(1)
                            avanzar_recto_grados(60,900,-90)
                            reset_gyro(0)
                            angulo_correcion = correccion_derecha(15)
                            reset_gyro(angulo_correcion)
                            time.sleep(0.1)
                            v = v + 1
                        avanzar_recto_grados(60,550,0)
                
                else:
                    
                    direccion = avanzar_detection_lidar(60,0)
                    avanzar_recto_grados(60,300,0) # se va a aquitar con sensores

                    if direccion == izq:
                        vuelta_grados(izq,60,88)
                        centrar_vehiculo()
                        time.sleep(1)
                        avanzar_recto_grados(60,900,90)
                        angulo_correcion = correccion_izquierda()
                        reset_gyro(angulo_correcion)
                        time.sleep(0.1)
                        while v < 11:
                            avanzar_detection_izquierdo_lidar(60,0)
                            avanzar_recto_grados(60,300,90) # se va a aquitar con sensores
                            vuelta_grados(izq,60,88)
                            centrar_vehiculo()
                            time.sleep(1)
                            avanzar_recto_grados(60,900,90)
                            reset_gyro(0)
                            angulo_correcion = correccion_izquierda()
                            reset_gyro(angulo_correcion)
                            time.sleep(0.1)
                            v = v + 1
                        avanzar_recto_grados(60,550,0)
                    
                    if direccion == der:
                        vuelta_grados(der,60,88)
                        centrar_vehiculo()
                        time.sleep(1)
                        avanzar_recto_grados(60,900,-90)
                        angulo_correcion = correccion_derecha(15)
                        reset_gyro(angulo_correcion)
                        time.sleep(0.1)
                        while v < 11:
                            avanzar_detection_derecho_lidar(60,0)
                            vuelta_grados(der,60,88)
                            centrar_vehiculo()
                            time.sleep(1)
                            avanzar_recto_grados(60,900,-90)
                            reset_gyro(0)
                            angulo_correcion = correccion_derecha(15)
                            reset_gyro(angulo_correcion)
                            time.sleep(0.1)
                            v = v + 1
                        avanzar_recto_grados(60,550,0)
                time.sleep(0.001)
                                
                running = False
    
            except KeyboardInterrupt:
                print("\nProgram interrupted! Cleaning up...")
                spike.write(chr(3).encode())
                spike.readline() #clear buffer
                spike.readline() #clear buffer
                spike.readline() #clear buffer
                Coast_motors()
                spike.close()
                print("\nStopping...")
                running = False
                cleanup_gpio(h)
                lidar.stop()
                break
            
    except Exception as e:
        print(f"Error: {e}")
        cleanup_gpio(h)
    finally:
        running = False
        lidar.stop()
        lidar.disconnect()
        cleanup_gpio(h)

if __name__ == "__main__":
    # Set up signal handler for clean exit
    
    main()
    print("Exiting...")
