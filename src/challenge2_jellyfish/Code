#!/usr/bin/env python3
"""
The code is edited from docs (https://docs.luxonis.com/projects/api/en/latest/samples/Yolo/tiny_yolo/)
We add parsing from JSON files that contain configuration
"""

from pathlib import Path #libreria para llamar el modelo
import sys
import cv2 #libreria de proseamiento de imagenes
import depthai as dai
import numpy as np #libreria de procesamiento de numeros
import time
import argparse 
import json #texto de las etiquetas del modelo de entrenamiento
import blobconverter #archivo del modelo para la camara
import lgpio
import threading #libreria para hilos
import queue  #colas para hilos
import signal
from dataclasses import dataclass
from typing import Optional, List, Dict, Tuple
import serial
import subprocess
import os
import pty

# Configuracio para la vision de la camara
@dataclass
class PillarObservation:
    label: int           # "regresa el objeto rojo = 1, verde = 0, nada = -1"
    xmid: int   # En centÃ­metros
    ymid: int # -1.0 izquierda, 0 centro, +1.0 derecha
    area: float          # Marca de tiempo

# Configuracio para las sensores de gorve
@dataclass
class UltrasonicSensor:
    name: str
    trigger_pin: int
    echo_pin: int
    last_reading: Optional[float] = None
    last_update: float = 0.0  

# configracion para los pines de los sensores 
SENSORS = [
    UltrasonicSensor("izquierda", trigger_pin=13, echo_pin=13),
    UltrasonicSensor("frente", trigger_pin=19, echo_pin=19),
    UltrasonicSensor("derecha", trigger_pin=6, echo_pin=6)
]

vision_queue: "queue.Queue[PillarObservation]" = queue.Queue(maxsize=1)
# Performance tuning parameters
MIN_MEASURE_INTERVAL = 0.04  # 30ms between measurements (about 33Hz per sensor)
SENSOR_TIMEOUT = 0.06      # 50ms timeout for echo pulse (reduced from 100ms)
SETTLE_TIME = 0.002         # 2ms settling time between trigger and echo
DISPLAY_UPDATE_RATE = 10    # Hz for display updates

# Speed of sound in cm/us
SPEED_OF_SOUND = 34300 / 1000000  # cm/s to cm/us

# Global flag for thread control
running = True

# Thread-safe queue for sensor updates
sensor_queue = queue.Queue()

# parse arguments
parser = argparse.ArgumentParser()
parser.add_argument("-m", "--model", help="Provide model name or model path for inference",
                    default='yolov4_tiny_coco_416x416', type=str)
parser.add_argument("-c", "--config", help="Provide config path for inference",
                    default='json/yolov4-tiny.json', type=str)
args = parser.parse_args()

# parse config
configPath = Path(args.config)
if not configPath.exists():
    raise ValueError("Path {} does not exist!".format(configPath))

with configPath.open() as f:
    config = json.load(f)
nnConfig = config.get("nn_config", {})

# parse input shape
if "input_size" in nnConfig:
    W, H = tuple(map(int, nnConfig.get("input_size").split('x')))

# extract metadata
metadata = nnConfig.get("NN_specific_metadata", {})
classes = metadata.get("classes", {})
coordinates = metadata.get("coordinates", {})
anchors = metadata.get("anchors", {})
anchorMasks = metadata.get("anchor_masks", {})
iouThreshold = metadata.get("iou_threshold", {})
confidenceThreshold = metadata.get("confidence_threshold", {})

print(metadata)

# parse labels
nnMappings = config.get("mappings", {})
labels = nnMappings.get("labels", {})

# get model path
nnPath = args.model
if not Path(nnPath).exists():
    print("No blob found at {}. Looking into DepthAI model zoo.".format(nnPath))
    nnPath = str(blobconverter.from_zoo(args.model, shaves = 6, zoo_type = "depthai", use_cache=True))
# sync outputs
syncNN = True

# Create pipeline
pipeline = dai.Pipeline()

# Define sources and outputs
camRgb = pipeline.create(dai.node.ColorCamera)
detectionNetwork = pipeline.create(dai.node.YoloDetectionNetwork)
xoutRgb = pipeline.create(dai.node.XLinkOut)
nnOut = pipeline.create(dai.node.XLinkOut)

xoutRgb.setStreamName("rgb")
nnOut.setStreamName("nn")

# Properties
camRgb.setPreviewSize(W, H)

camRgb.setResolution(dai.ColorCameraProperties.SensorResolution.THE_1080_P)
camRgb.setInterleaved(False)
camRgb.setColorOrder(dai.ColorCameraProperties.ColorOrder.BGR)
camRgb.setFps(40)

# Network specific settings
detectionNetwork.setConfidenceThreshold(confidenceThreshold)
detectionNetwork.setNumClasses(classes)
detectionNetwork.setCoordinateSize(coordinates)
detectionNetwork.setAnchors(anchors)
detectionNetwork.setAnchorMasks(anchorMasks)
detectionNetwork.setIouThreshold(iouThreshold)
detectionNetwork.setBlobPath(nnPath)
detectionNetwork.setNumInferenceThreads(2)
detectionNetwork.input.setBlocking(False)

# Linking
camRgb.preview.link(detectionNetwork.input)
detectionNetwork.passthrough.link(xoutRgb.input)
detectionNetwork.out.link(nnOut.input)
#==================================================spike functions ======================================
#=========================================================================================================
def screenSimplified(): #Called main() in the original script, renamed to avoid conflict with the main function in this module.
    if not os.path.exists("/dev/ttyACM0"):
        return

    master_fd, slave_fd = pty.openpty() 
    
    subprocess.Popen( 
        ["screen", "/dev/ttyACM0", "115200"],
        stdin=slave_fd, 
        stdout=slave_fd,
        stderr=slave_fd,
    )

    os.close(slave_fd)
    time.sleep(1.0)
    os.write(master_fd, b'\x03') # Send Ctrl+C to screen
    time.sleep(0.2)
    os.write(master_fd, b'\x01') # Send Ctrl+A to screen
    time.sleep(0.2)
    os.write(master_fd, b'k') # Send 'k' to kill the screen session
    time.sleep(0.2)
    os.write(master_fd, b'y') # Send 'y' to confirm kill
    time.sleep(0.2)
    
    os.close(master_fd)
    
"""End of simplified script, originated from "interpreter_startup.py" """

spike = serial.Serial('/dev/ttyACM0', 115200, timeout=1)
#variables globales rasp
der = -1
izq = 1

def initialize_Libraries():
    spike.write("import motor\r".encode()) 
    spike.readline()
    spike.write("from hub import port\r".encode())
    spike.readline()#clear buffer
    spike.write("from hub import motion_sensor\r".encode())
    spike.readline()#clear buffer
    spike.write("import distance_sensor\r".encode())
    spike.readline()#clear buffer
    #declare varianbles globales spike
    spike.write("der = -1\r".encode())
    spike.readline() #clear buffer
    spike.write("izq = 1\r".encode())
    spike.readline() #clear buffer
    spike.write("error = 0\r".encode())
    spike.readline() #clear buffer
    #declare functions for motors
    spike.write("def fr():\r".encode())
    spike.readline() #clear buffer 
    spike.write("motor.stop(port.F, stop = motor.HOLD)\r".encode())
    spike.readline() #clear buffer 
    spike.write("motor.stop(port.B, stop = motor.HOLD)\r".encode())
    spike.readline() #clear buffer
    end_Function()

    spike.write("def fc():\r".encode())
    spike.readline() #clear buffer 
    spike.write("motor.stop(port.F, stop = motor.COAST)\r".encode())
    spike.readline() #clear buffer 
    spike.write("motor.stop(port.B, stop = motor.COAST)\r".encode())
    spike.readline() #clear buffer
    end_Function()
    # centrar el vehiculo 
    spike.write("def cv():\r".encode())
    spike.readline() #clear buffer 
    spike.write("motor.run_to_absolute_position(port.F, 0, 550,\r".encode())
    spike.readline()#clear buffemotor.stop(port.F, stop = motor.COAST)r
    spike.write("direction = motor.SHORTEST_PATH, stop = motor.HOLD, acceleration = 1000, deceleration = 1000)\r".encode())
    spike.readline() #clear buffer
    spike.write("return 255\r".encode())
    spike.readline() #clear buffer
    end_Function()

    #pd 
    spike.write("def pd(s1,s2,vel,kp,kd,ea):\r".encode()) #ea es error anterior
    spike.readline() #clear buffer 
    spike.write("error=s1-s2\r".encode())
    spike.readline()#clear buffer
    spike.write("et= (kp*error) + (kd*(error-ea))\r".encode()) #et es error total
    spike.readline()#clear buffer
    spike.readline() #clear buffer
    spike.write("motor.run_to_absolute_position(port.F, int(et), 300, direction = motor.SHORTEST_PATH, stop = motor.HOLD, acceleration = 10000)\r".encode())
    spike.readline() #clear buffer
    spike.write("motor.set_duty_cycle(port.B, (-100)*(vel))\r".encode())
    spike.readline() #clear buffer
    spike.write("return error\r".encode())
    spike.readline() #clear buffer
    end_Function()

    #reset Gyro
    spike.write("def rg(grados):\r".encode())
    spike.readline() #clear buffer
    spike.write("motion_sensor.reset_yaw(grados)\r".encode())
    spike.readline() #clear buffer
    end_Function()

    #avanzar derecho
    spike.write("def ad(vel,referencia):\r".encode())
    spike.readline() #clear buffer
    spike.write("global error\r".encode())
    spike.readline() #clear buffer
    spike.write("error = pd(((10)*(referencia)),motion_sensor.tilt_angles()[0],vel,0.3,1,error)\r".encode())
    spike.readline() #clear buffer 
    end_Function()

    #avanzar derecho indefinido
    spike.write("def ai(vel,referencia):\r".encode())
    spike.readline() #clear buffer
    spike.write("error = 0\r".encode())
    spike.readline() #clear buffer
    spike.write("while 1:\r".encode())
    spike.readline() #clear buffer
    spike.write("error = pd(((10)*(referencia)),motion_sensor.tilt_angles()[0],vel,0.3,1,error)\r".encode())
    spike.readline() #clear buffer 
    spike.write(chr(127).encode()) #suprimir linea
    spike.readline() #clear buffer
    end_Function()

    spike.write("def vuelta(direccion,velocidad,grados):\r".encode())
    spike.readline() #clear buffer
    spike.write("motor.run_to_absolute_position(port.F, 49*(direccion), 550, direction = motor.SHORTEST_PATH)\r".encode())
    spike.readline() #clear buffer
    spike.write("while abs(grados*10) > abs(motion_sensor.tilt_angles()[0]):\r".encode())
    spike.readline() #clear buffer
    spike.write("motor.set_duty_cycle(port.B, (-100)*(velocidad))\r".encode())
    spike.readline() #clear buffer
    spike.write(chr(127).encode()) #suprimir linea
    spike.readline() #clear buffer
    spike.write("fr()\r".encode())   
    spike.readline() #clear buffer
    spike.write("return 255\r".encode())
    spike.readline() #clear buffer
    end_Function()
    end_Function()

    spike.write("def vuelta_inversa(direccion,velocidad,grados):\r".encode())
    spike.readline() #clear buffer
    spike.write("motor.run_to_absolute_position(port.F, 49*(direccion), 550, direction = motor.SHORTEST_PATH)\r".encode())
    spike.readline() #clear buffer
    spike.write("while abs(grados*10) < abs(motion_sensor.tilt_angles()[0]):\r".encode())
    spike.readline() #clear buffer
    spike.write("motor.set_duty_cycle(port.B, (-100)*(velocidad))\r".encode())
    spike.readline() #clear buffer
    spike.write(chr(127).encode()) #suprimir linea
    spike.readline() #clear buffer
    spike.write("fr()\r".encode())   
    spike.readline() #clear buffer
    spike.write("return 255\r".encode())
    spike.readline() #clear buffer
    end_Function()
    end_Function()

    spike.write("def vuelta_retroceder(direccion,velocidad,grados):\r".encode())
    spike.readline() #clear buffer
    spike.write("motor.run_to_absolute_position(port.F, 49*(direccion), 550, direction = motor.SHORTEST_PATH)\r".encode())
    spike.readline() #clear buffer
    spike.write("while abs(grados*10) > abs(motion_sensor.tilt_angles()[0]):\r".encode())
    spike.readline() #clear buffer
    spike.write("motor.set_duty_cycle(port.B, (100)*(velocidad))\r".encode())
    spike.readline() #clear buffer
    spike.write(chr(127).encode()) #suprimir linea
    spike.readline() #clear buffer
    spike.write("fr()\r".encode())   
    spike.readline() #clear buffer
    spike.write("return 255\r".encode())
    spike.readline() #clear buffer
    end_Function()
    end_Function()


    spike.write("def da(vel, referencia):\r".encode())
    spike.readline() #clear buffer
    spike.write("global error\r".encode())
    spike.readline() #clear buffer
    spike.write("error = pd(referencia,motion_sensor.tilt_angles()[0],vel,0.3,1,error)\r".encode())
    spike.readline() #clear buffer
    end_Function()

    spike.write("def ag(vel,grados,referencia):\r".encode())
    spike.readline() #clear buffer
    spike.write("error = 0\r".encode())
    spike.readline() #clear buffer
    spike.write("motor.reset_relative_position(port.B,0)\r".encode())
    spike.readline() #clear buffer
    spike.write("while abs(grados) > abs(motor.relative_position(port.B)):\r".encode())
    spike.readline() #clear buffer
    spike.write("error = pd(((10)*(referencia)),motion_sensor.tilt_angles()[0],vel,0.3,1,error)\r".encode())
    spike.readline() #clear buffer
    spike.write(chr(127).encode()) #suprimir linea
    spike.readline() #clear buffer
    spike.write("fc()\r".encode())
    spike.readline() #clear buffer
    spike.write("return 255\r".encode())
    spike.readline() #clear buffer
    end_Function()
    end_Function()

    spike.write("def spd(vel,distancia,sensor):\r".encode())
    spike.readline() #clear buffer
    spike.write("global error\r".encode())
    spike.readline() #clear buffer
    spike.write("error = pd(distancia,sensor,vel,0.3,1,error)\r".encode())
    spike.readline() #clear buffer
    spike.write("return motor.relative_position(port.B)\r".encode())
    spike.readline() #clear buffer
    end_Function()

    spike.write("def spi(vel,distancia,sensor):\r".encode())
    spike.readline() #clear buffer
    spike.write("global error\r".encode())
    spike.readline() #clear buffer
    spike.write("error = pd(sensor,distancia,vel,0.3,1,error)\r".encode())
    spike.readline() #clear buffer
    spike.write("return motor.relative_position(port.B)\r".encode())
    spike.readline() #clear buffer
    end_Function()


def centrar_vehiculo():
    spike.write("cv()\r".encode())
    spike.readline() #clear buffer    return_value = spike.readline().decode()
    return_value = spike.readline().decode()
    if return_value == "":
        return_value = "0"
    while int(return_value) != 255:
        return_value = spike.readline().decode()
        if return_value == "":
            return_value = "0"
    print("Fin de la vuelta")
    Free_spikeDirection()
    time.sleep(0.01)

def Free_spikeDirection():
    spike.write("fr()\r".encode())
    spike.readline() #clear buffer

def Coast_motors():
    spike.write("fc()\r".encode())
    spike.readline() #clear buffer


def end_Function():
    spike.write("\r".encode())
    spike.readline()#clear 
    spike.write("\r".encode())
    spike.readline()#clear buffer
    spike.write("\r".encode())
    spike.readline()#clear buffer
    
def reset_gyro(grados):
    spike.write(("rg("+str(grados)+")\r").encode())
    spike.readline() #clear buffer
    
def avanzar_distancia(vel,distancia,referencia):
    uls = [2000,2000,2000]
    i = 0
    while ((distancia*10) < uls[1]) or (uls[1] == -1):
        i = 0
        for sensor in SENSORS:
            if sensor.last_reading is not None:
                uls[i] = int(sensor.last_reading)
            i = i + 1
        spike.write(("ad("+str(vel)+","+str(referencia)+")\r").encode())
        spike.readline() #clear buffer
        print(uls[1])
    print("Fin del recorrido")

    Coast_motors()

def vuelta_grados(direccion,velocidad,grados):
    spike.write(("vuelta("+str(direccion)+","+str(velocidad)+","+str(grados)+")\r").encode())
    spike.readline() #clear buffer
    return_value = spike.readline().decode()
    if return_value == "":
        return_value = "0"
    while int(return_value) != 255:
        return_value = spike.readline().decode()
        if return_value == "":
            return_value = "0"
    print("Fin de la vuelta")
    Free_spikeDirection()
    time.sleep(0.01)

def vuelta_grados_inversa(direccion,velocidad,grados):
    spike.write(("vuelta_inversa("+str(direccion)+","+str(velocidad)+","+str(grados)+")\r").encode())
    spike.readline() #clear buffer
    return_value = spike.readline().decode()
    if return_value == "":
        return_value = "0"
    while int(return_value) != 255:
        return_value = spike.readline().decode()
        if return_value == "":
            return_value = "0"
    print("Fin de la vuelta")
    Free_spikeDirection()
    time.sleep(0.01)

def vuelta_grados_retroceder(direccion,velocidad,grados):
    spike.write(("vuelta_retroceder("+str(direccion)+","+str(velocidad)+","+str(grados)+")\r").encode())
    spike.readline() #clear buffer
    return_value = spike.readline().decode()
    if return_value == "":
        return_value = "0"
    while int(return_value) != 255:
        return_value = spike.readline().decode()
        if return_value == "":
            return_value = "0"
    print("Fin de la vuelta")
    Free_spikeDirection()
    time.sleep(0.01)

def avanzar_detection(vel,referencia):
    uls = [1,1,1]
    i = 0
    while uls[0] > 0 and uls[2] > 0 and uls[0] < 2000 and uls[2] < 2000:
        i = 0
        for sensor in SENSORS:
            if sensor.last_reading is not None:
                uls[i] = int(sensor.last_reading)
            i = i + 1
        spike.write(("da("+str(vel)+","+str(referencia)+")\r").encode())
        spike.readline() #clear buffer
    return uls
    #Coast_motors()

def avanzar_detection_izquierdo(vel,referencia):
    uls = [1,1,1]
    i = 0
    while uls[0] > 0 and uls[0] < 2000:
        i = 0
        for sensor in SENSORS:
            if sensor.last_reading is not None:
                uls[i] = int(sensor.last_reading)
            i = i + 1
        spike.write(("da("+str(vel)+","+str(referencia)+")\r").encode())
        spike.readline() #clear buffer
    return uls
    #Coast_motors()

def avanzar_detection_derecho(vel,referencia):
    uls = [1,1,1]
    i = 0
    while uls[2] > 0 and uls[2] < 2000:
        i = 0
        for sensor in SENSORS:
            if sensor.last_reading is not None:
                uls[i] = int(sensor.last_reading)
            i = i + 1
        spike.write(("da("+str(vel)+","+str(referencia)+")\r").encode())
        spike.readline() #clear buffer
    return uls
    #Coast_motors()


def avanzar_detection_gyro(vel,referencia):
    uls = [1,1,1]
    i = 0
    spike.write(("ai("+str(vel)+","+str(referencia)+")\r").encode()) #suprimir linea
    spike.readline() #clear buffer
    while uls[0] > 0 and uls[2] > 0 and uls[0] < 2000 and uls[2] < 2000:
        i = 0
        for sensor in SENSORS:
            if sensor.last_reading is not None:
                uls[i] = int(sensor.last_reading)
            i = i + 1
    spike.write(chr(3).encode())
    spike.readline() #clear buffer
    spike.readline() #clear buffer
    spike.readline() #clear buffer
    spike.readline() #clear buffer
    Coast_motors()

def vuelta_automatica(velocidad, grados, uls):
    while 1:
        if uls[0] == -1 or uls[2] == -1:
            break
        i = 0
        for sensor in SENSORS:
            if sensor.last_reading is not None:
                uls[i] = int(sensor.last_reading)
            i = i + 1    
    print("vuelta = ",uls,"\n")
    if uls[0] == -1:
        vuelta_grados(izq,velocidad,grados)
    elif uls[2] == -1:
        vuelta_grados(der,velocidad,grados)
    Free_spikeDirection()

def avanzar_recto_grados(velocidad,grados,referencia):
    spike.write(("ag("+str(velocidad)+","+str(grados)+","+str(referencia)+")\r").encode())
    spike.readline() #clear buffer
    return_value = spike.readline().decode()
    if return_value == "":
        return_value = "0"
    while int(return_value) != 255:
        return_value = spike.readline().decode()
        if return_value == "":
            return_value = "0"
    print("Fin de la vuelta")
    Coast_motors()

def seguir_pared_derecho(velocidad,grados):
    uls = [1,1,1]
    i = 0
    for sensor in SENSORS:
        if sensor.last_reading is not None:
            uls[i] = int(sensor.last_reading)
        i = i + 1
    ditancia_Inicial = uls[2]
    spike.write("motor.reset_relative_position(port.B)\r".encode())
    spike.readline() #clear buffer
    gradosMotor = 0
    while abs(gradosMotor) < grados:
        i = 0
        for sensor in SENSORS:
            if sensor.last_reading is not None:
                uls[i] = int(sensor.last_reading)
            i = i + 1
        spike.write(("spd("+str(velocidad)+","+str(ditancia_Inicial)+","+str(uls[2])+")\r").encode())
        spike.readline() #clear buffer
        gradosMotor = int(spike.readline().decode())
    Coast_motors()


def seguir_pared_izquierdo(velocidad,grados):
    uls = [1,1,1]
    i = 0
    for sensor in SENSORS:
        if sensor.last_reading is not None:
            uls[i] = int(sensor.last_reading)
        i = i + 1
    ditancia_Inicial = uls[0]
    spike.write("motor.reset_relative_position(port.B)\r".encode())
    spike.readline() #clear buffer
    gradosMotor = 0
    while abs(gradosMotor) < grados:
        i = 0
        for sensor in SENSORS:
            if sensor.last_reading is not None:
                uls[i] = int(sensor.last_reading)
            i = i + 1
        spike.write(("spi("+str(velocidad)+","+str(ditancia_Inicial)+","+str(uls[0])+")\r").encode())
        spike.readline() #clear buffer
        gradosMotor = int(spike.readline().decode())
    Coast_motors()

def get_distance(h: int, sensor: UltrasonicSensor) -> Optional[float]:
    """Measures distance using an ultrasonic sensor with minimal latency."""
    try:
        # Send trigger pulse (minimal delay)
        lgpio.gpio_claim_output(h, sensor.trigger_pin)
        lgpio.gpio_write(h, sensor.trigger_pin, 0)
        time.sleep(0.00001)  # 1us (minimum)
        lgpio.gpio_write(h, sensor.trigger_pin, 1)
        time.sleep(0.000010)  # 10us (required by HC-SR04)
        lgpio.gpio_write(h, sensor.trigger_pin, 0)
        
        # Switch to input mode for echo (no delay)
        lgpio.gpio_claim_input(h, sensor.echo_pin)

        # Wait for the pulse to start (with timeout)
        timeout = time.time() + SENSOR_TIMEOUT
        while lgpio.gpio_read(h, sensor.echo_pin) == 0:
            if time.time() > timeout:
                return None

        pulse_start = time.time()
        
        # Wait for the pulse to end (with timeout)
        timeout = time.time() + SENSOR_TIMEOUT
        while lgpio.gpio_read(h, sensor.echo_pin) == 1:
            if time.time() > timeout:
                return None
        
        pulse_end = time.time()
        
        # Calculate distance in cm
        pulse_duration = pulse_end - pulse_start
        distance = (pulse_duration * SPEED_OF_SOUND * 10000000) / 2

        # Filter out invalid readings
        if 20 <= distance <= 2000:  # 4m max reliable range
            return distance
        else:
            return -1

    except Exception as e:
        print(f"Error reading {sensor.name} sensor: {e}")
        return None

def sensor_worker(h: int, sensor: UltrasonicSensor):
    """Worker function to continuously read a sensor with minimal latency"""
    last_measure_time = 0
    
    while running:
        current_time = time.time()
        
        # Only measure if enough time has passed since last measurement
        if current_time - last_measure_time >= MIN_MEASURE_INTERVAL:
            distance = get_distance(h, sensor)
            if distance is not None:
                sensor.last_reading = distance
                sensor.last_update = current_time
                sensor_queue.put((sensor.name, distance))
            last_measure_time = current_time
        else:
            # Small sleep to prevent 100% CPU usage
            time.sleep(0.001)  # 1ms

def setup_gpio():
    """Initialize GPIO and claim all necessary pins"""
    try:
        h = lgpio.gpiochip_open(0)
        
        # Setup all sensor pins
        for sensor in SENSORS:
            lgpio.gpio_claim_output(h, sensor.trigger_pin)
            lgpio.gpio_claim_input(h, sensor.echo_pin)
            lgpio.gpio_write(h, sensor.trigger_pin, 0)  # Ensure trigger is low
        lgpio.gpio_claim_input(h, 4)

        # Let sensors settle
        print("Initializing sensors...")
        time.sleep(1)
        return h, True
        
    except Exception as e:
        print(f"GPIO initialization failed: {e}")
        return None, False

def cleanup_gpio(h):
    """Release all GPIO resources"""
    try:
        for sensor in SENSORS:
            try:
                lgpio.gpio_free(h, sensor.trigger_pin)
                lgpio.gpio_free(h, sensor.echo_pin)
            except:
                pass
        lgpio.gpio_free(h, 4) #input pin
        lgpio.gpiochip_close(h)
        print("GPIO resources cleaned up")
    except:
        pass


#===============================================End spike functions ======================================
#=========================================================================================================
# nn data, being the bounding box locations, are in <0..1> range - they need to be normalized with frame width/height
vision_queue: "queue.Queue[PillarObservation]" = queue.Queue(maxsize=1)
def object_Color(obs:PillarObservation):
    """Devuelve -1 si debe mantener derecha, +1 si izquierda."""
    if obs == None:
        return -1
    else:
        objeto = obs.label  
        return objeto

def object_Area(obs:PillarObservation):
    """Devuelve -1 si debe mantener derecha, +1 si izquierda."""
    if obs == None:
        return -1
    else:
        objeto = obs.area  
        return objeto

def object_Orientation(obs:PillarObservation):
    """Devuelve -1 si debe mantener derecha, +1 si izquierda."""
    if obs == None:
        return 0
    else:
        objeto = (obs.xmid - 0.5)*(-300)
        return objeto
#normaliza los valores de la imagen 
def frameNorm(frame, bbox):
    normVals = np.full(len(bbox), frame.shape[0])
    normVals[::2] = frame.shape[1]
    return (np.clip(np.array(bbox), 0, 1) * normVals).astype(int)

def displayFrame(name, frame, detections):
    color = (255, 0, 0)
    for detection in detections:
        bbox = frameNorm(frame, (detection.xmin, detection.ymin, detection.xmax, detection.ymax)) 
        cv2.putText(frame, labels[detection.label], (bbox[0] + 10, bbox[1] + 20), cv2.FONT_HERSHEY_TRIPLEX, 0.5, 255) #imprime el nombre del objeto en la imagen
        cv2.putText(frame, f"{int(detection.confidence * 100)}%", (bbox[0] + 10, bbox[1] + 40), cv2.FONT_HERSHEY_TRIPLEX, 0.5, 255) #imprime el porcentaje de seguridad en la imagen
        cv2.rectangle(frame, (bbox[0], bbox[1]), (bbox[2], bbox[3]), color, 2) #dibuja el rectangulo en la imagen
    # Show the frame
    cv2.imshow(name, frame)

def vision_worker():
    counter = 0
    while running:
        try:
            area = [0,0,0,0,0,0]
            max_index = 0
            best: Optional[PillarObservation] = None
            #inRgb = qRgb.get() #remover para ver video
            inDet = qDet.get()
            #if inRgb is not None: #remover para ver video
            #    frame = inRgb.getCvFrame() #remover para ver video
             #   cv2.putText(frame, "NN fps: {:.2f}".format(counter / (time.monotonic() - startTime)), #remover para ver video
              #  (2, frame.shape[0] - 4), cv2.FONT_HERSHEY_TRIPLEX, 0.4, color2) #imprime el fps en la imagen #remover para ver video
            if inDet is not None:
                detections = inDet.detections
                counter += 1         
                i = 0      
                for detection in detections:     
                    area[i] = ((detection.xmax - detection.xmin) * (detection.ymax - detection.ymin))*(100)
                    i += 1 
                if i != 0:
                    max_index = np.argmax(area)
                    xmid = (detections[max_index].xmin + detections[max_index].xmax)/2
                    ymid = (detections[max_index].ymin + detections[max_index].ymax)/2
                    obj = PillarObservation(label=detections[max_index].label,xmid=xmid,ymid=ymid,area=area[max_index])  
                    if best is None:
                        best = obj
            #if frame is not None: #remover para ver video
             #   displayFrame("rgb", frame, detections) #remover para ver video
              #  if cv2.waitKey(1) == ord('q'):#remover para ver video
               #     break
            if best is not None:
                if vision_queue.full():
                    try:
                        vision_queue.get_nowait()
                    except queue.Empty:
                        pass
                vision_queue.put(best)

        except Exception as e:
            print("[Vision] Error:", e)
            time.sleep(0.5)
#============================================= depthai functions =========================================

#funciones con la vision de la camara

def avanzar_cubitos(area):
    obs: Optional[PillarObservation] = None
    i = 0
    uls = [1,1,1]
    for sensor in SENSORS:
        if sensor.last_reading is not None:
            uls[i] = int(sensor.last_reading)
        i = i + 1
    if vision_queue.full():
        try:
            obs = vision_queue.get_nowait()
        except queue.Empty:
            pass
    while object_Area(obs) < area:
        i = 0
        for sensor in SENSORS:
            if sensor.last_reading is not None:
                uls[i] = int(sensor.last_reading)
            i = i + 1
        if uls[1] != -1 and uls[1] < 250 and uls[0] == -1:
            break
        spike.write(("da("+str(50)+","+str(0)+")\r").encode())
        spike.readline() #clear buffer
        if vision_queue.full():
            try:
                obs = vision_queue.get_nowait()
                print(obs)
            except queue.Empty:
                pass
    Coast_motors()
    return obs


def seguir_cubitos(area):
    obs: Optional[PillarObservation] = None
    while not vision_queue.full():
        if vision_queue.full():
            try:
                obs = vision_queue.get_nowait()
                print(obs)
            except queue.Empty:
                pass
    while object_Area(obs) < area:
        orientation = object_Orientation(obs)
        spike.write(("da("+str(50)+","+str(orientation)+")\r").encode())
        spike.readline() #clear buffer
        if vision_queue.full():
            try:
                obs = vision_queue.get_nowait()
                print(obs)
            except queue.Empty:
                pass
    Coast_motors()







# Connect to device and start pipeline
with dai.Device(pipeline) as device:

    # Output queues will be used to get the rgb frames and nn data from the outputs defined above
    qRgb = device.getOutputQueue(name="rgb", maxSize=4, blocking=False)
    qDet = device.getOutputQueue(name="nn", maxSize=4, blocking=False)
    screenSimplified() #pone el brick en modo interprete

    frame = None
    detections = []
    startTime = time.monotonic()
    color2 = (255, 255, 255)


    print("Multi-Sensor Ultrasonic Distance Measurement")
    print("Sensors:")
    for sensor in SENSORS:
        print(f"  {sensor.name}: GPIO{sensor.trigger_pin}")
    print("Press Ctrl+C to exit\n")
    
    # Initialize GPIO
    h, success = setup_gpio()
    try:
        threads = []
        for sensor in SENSORS:
            t = threading.Thread(
                target=sensor_worker,
                args=(h, sensor),  # No fixed interval, uses timing control
                daemon=True
            )
            t.start()
            threads.append(t)
        threading.Thread(target=vision_worker, daemon=True).start()
        initialize_Libraries()
        print("presiona el boton\n")
        while(lgpio.gpio_read(h, 4) == 1):# Start sensor worker threads with high priority
            a = 0
        i = 0
        print("empezando ....\n")
        ulsc = [1,1,1]
        for sensor in SENSORS:
            if sensor.last_reading is not None:
                ulsc[i] = int(sensor.last_reading)
            i = i + 1
        reset_gyro(0)
        # Main display loop
        last_display = 0
        while running:
            try:
                print("iniciando reto 2\n")
                """avanzar_distancia(50,3,0)
                Free_spikeDirection()
                vuelta_grados_retroceder(-1,50,90)"""
                #time.sleep(1)
                #vuelta_grados(-1,50,30)
                #time.sleep(1)
                #avanzar_distancia(50,67.5,0)
                #time.sleep(5)
                #vuelta_grados(1,50,90)
                #Coast_motors()  
                v = 0
                while v < 12:
                    v = v+1 
                    print(ulsc)
                    while 1:
                        ulsc = [1,1,1]
                        i = 0
                        for sensor in SENSORS:
                            if sensor.last_reading is not None:
                                ulsc[i] = int(sensor.last_reading)
                            i = i + 1
                        reset_gyro(0)
                        obs = avanzar_cubitos(8.0)
                        if obs != None:
                            if obs.label == 1:
                                if (obs.xmid > 0.5):
                                    vuelta_grados(-1,60,30 + ((obs.xmid - 0.5)*25))
                                    centrar_vehiculo()
                                    avanzar_recto_grados(60,360,-(30 + ((obs.xmid - 0.5)*25)))
                                    centrar_vehiculo()
                                    avanzar_recto_grados(60,90,0)
                                    vuelta_grados(1,60,30 + ((obs.xmid - 0.5)*25))
                                    centrar_vehiculo()
                                    avanzar_recto_grados(60,220,(30 + ((obs.xmid - 0.5)*25)))
                                    centrar_vehiculo()
                                else:
                                    avanzar_recto_grados(60,360,0)
                                    vuelta_grados(-1,60,20 + ((obs.xmid - 0.5)*25))
                                avanzar_recto_grados(60,120,0)
                        centrar_vehiculo()
                        obs = avanzar_cubitos(8.0)
                        print("while obs\n")
                        print(obs)
                        if obs != None:
                            if obs.label == 0:
                                if (obs.xmid < 0.5):
                                    vuelta_grados(1,60,30 - ((obs.xmid - 0.5)*27))
                                    centrar_vehiculo()
                                    avanzar_recto_grados(60,400,(30 - ((obs.xmid - 0.5)*27)))
                                    centrar_vehiculo()
                                    avanzar_recto_grados(60,650,0)
                                    vuelta_grados(-1,60,30 +((obs.xmid - 0.5)*27))
                                    centrar_vehiculo()
                                    avanzar_recto_grados(60,460,-(30 - ((obs.xmid - 0.5)*27)))
                                    centrar_vehiculo()
                                else:
                                    avanzar_recto_grados(60,360,0)
                                    vuelta_grados(1,60,20 - ((obs.xmid - 0.5)*27))
                                avanzar_recto_grados(70,650,0)
                        if(ulsc[1]< 350 or ulsc[1] == -1):
                            
                            print("meet\n")    

                            avanzar_distancia(50,3,0)
                            Free_spikeDirection()
                            vuelta_grados_retroceder(-1,50,90)
                            reset_gyro(0)
                            time.sleep(10)



                """if object_Color(obs) == 1:
                    vuelta_grados(-1,50,45)
                    vuelta_grados(1,50,0)"""
                Coast_motors()
                time.sleep(3)
                running = False
            except KeyboardInterrupt:
                print("\nProgram interrupted! Cleaning up...")
                spike.write(chr(3).encode())
                spike.readline() #clear buffer
                spike.readline() #clear buffer
                spike.readline() #clear buffer
                Coast_motors()
                spike.close()
                print("\nStopping...")
                running = False
                cleanup_gpio(h)
                break
        # Wait for threads to finish
        for t in threads:
            t.join(timeout=1.0)
            
    except Exception as e:
        print(f"Error: {e}")
        cleanup_gpio(h)
    finally:
        running = False
        cleanup_gpio(h)
